{"id": "flask:src/flask/logging.py", "language": "python", "code": "from __future__ import annotations\n\nimport logging\nimport sys\nimport typing as t\n\nfrom werkzeug.local import LocalProxy\n\nfrom .globals import request\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from .sansio.app import App\n\n\n@LocalProxy\ndef wsgi_errors_stream() -> t.TextIO:\n    \"\"\"Find the most appropriate error stream for the application. If a request\n    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\n    If you configure your own :class:`logging.StreamHandler`, you may want to\n    use this for the stream. If you are using file or dict configuration and\n    can't import this directly, you can refer to it as\n    ``ext://flask.logging.wsgi_errors_stream``.\n    \"\"\"\n    if request:\n        return request.environ[\"wsgi.errors\"]  # type: ignore[no-any-return]\n\n    return sys.stderr\n\n\ndef has_level_handler(logger: logging.Logger) -> bool:\n    \"\"\"Check if there is a handler in the logging chain that will handle the\n    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n    \"\"\"\n    level = logger.getEffectiveLevel()\n    current = logger\n\n    while current:\n        if any(handler.level <= level for handler in current.handlers):\n            return True\n\n        if not current.propagate:\n            break\n\n        current = current.parent  # type: ignore\n\n    return False\n\n\n#: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format\n#: ``[%(asctime)s] %(levelname)s in %(module)s: %(message)s``.\ndefault_handler = logging.StreamHandler(wsgi_errors_stream)  # type: ignore\ndefault_handler.setFormatter(\n    logging.Formatter(\"[%(asctime)s] %(levelname)s in %(module)s: %(message)s\")\n)\n\n\ndef create_logger(app: App) -> logging.Logger:\n    \"\"\"Get the Flask app's logger and configure it if needed.\n\n    The logger name will be the same as\n    :attr:`app.import_name <flask.Flask.name>`.\n\n    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n    :data:`logging.DEBUG` if it is not set.\n\n    If there is no handler for the logger's effective level, add a\n    :class:`~logging.StreamHandler` for\n    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n    \"\"\"\n    logger = logging.getLogger(app.name)\n\n    if app.debug and not logger.level:\n        logger.setLevel(logging.DEBUG)\n\n    if not has_level_handler(logger):\n        logger.addHandler(default_handler)\n\n    return logger\n", "metadata": {"license": "BSD-3-Clause", "len_tokens": 566}, "prompt": "Write a Python function named wsgi_errors_stream decorated with @LocalProxy from werkzeug.local that returns the appropriate error stream for a Flask application. The function should check if a Flask request is currently active using the request object from flask.globals. If a request is active, return the WSGI error stream from request.environ[\"wsgi.errors\"]. If no request is active, return sys.stderr as a fallback. The return type should be annotated as t.TextIO where t is typing imported as t. Include these imports: from __future__ import annotations, import sys, import typing as t, from werkzeug.local import LocalProxy, from .globals import request. Add a comprehensive docstring explaining that this function finds the most appropriate error stream for the application, that if a request is active it logs to wsgi.errors otherwise uses sys.stderr, and that it can be referenced as ext://flask.logging.wsgi_errors_stream for file or dict configuration. Add a type ignore comment after the return statement for the environ access with the text type: ignore[no-any-return]. Output only the code with no explanation before or after.", "notes": "Review and refine this prompt manually for fidelity."}
{"id": "flask:src/flask/sessions.py", "language": "python", "code": "class SessionMixin(MutableMapping[str, t.Any]):\n    \"\"\"Expands a basic dictionary with session attributes.\"\"\"\n\n    @property\n    def permanent(self) -> bool:\n        \"\"\"This reflects the ``'_permanent'`` key in the dict.\"\"\"\n        return self.get(\"_permanent\", False)  # type: ignore[no-any-return]\n\n    @permanent.setter\n    def permanent(self, value: bool) -> None:\n        self[\"_permanent\"] = bool(value)\n\n    #: Some implementations can detect whether a session is newly\n    #: created, but that is not guaranteed. Use with caution. The mixin\n    # default is hard-coded ``False``.\n    new = False\n\n    #: Some implementations can detect changes to the session and set\n    #: this when that happens. The mixin default is hard coded to\n    #: ``True``.\n    modified = True\n\n    #: Some implementations can detect when session data is read or\n    #: written and set this when that happens. The mixin default is hard\n    #: coded to ``True``.\n    accessed = True", "metadata": {"license": "BSD-3-Clause", "len_tokens": 225}, "prompt": "Write a Python class SessionMixin that inherits from MutableMapping with generic types str and t.Any from typing module. Add a property named permanent with a getter that returns the value of key '_permanent' from the dict using self.get with default False, and a setter that stores the boolean conversion of the input value. Add three class attributes: new set to False, modified set to True, and accessed set to True. Include a class docstring stating it expands a basic dictionary with session attributes. Add a docstring for the permanent property explaining it reflects the '_permanent' key in the dict. Add inline comments for new, modified, and accessed explaining they track whether session is newly created, modified, or accessed. Include type ignore comment for the permanent getter return statement. Import typing as t and MutableMapping from collections.abc. Output only code.", "notes": "Review and refine this prompt manually for fidelity."}
{"id": "flask:src/flask/sessions.py", "language": "python", "code": "class SecureCookieSession(CallbackDict[str, t.Any], SessionMixin):\n    \"\"\"Base class for sessions based on signed cookies.\n\n    This session backend will set the :attr:`modified` and\n    :attr:`accessed` attributes. It cannot reliably track whether a\n    session is new (vs. empty), so :attr:`new` remains hard coded to\n    ``False``.\n    \"\"\"\n\n    #: When data is changed, this is set to ``True``. Only the session\n    #: dictionary itself is tracked; if the session contains mutable\n    #: data (for example a nested dict) then this must be set to\n    #: ``True`` manually when modifying that data. The session cookie\n    #: will only be written to the response if this is ``True``.\n    modified = False\n\n    #: When data is read or written, this is set to ``True``. Used by\n    # :class:`.SecureCookieSessionInterface` to add a ``Vary: Cookie``\n    #: header, which allows caching proxies to cache different pages for\n    #: different users.\n    accessed = False\n\n    def __init__(\n        self,\n        initial: c.Mapping[str, t.Any] | c.Iterable[tuple[str, t.Any]] | None = None,\n    ) -> None:\n        def on_update(self: te.Self) -> None:\n            self.modified = True\n            self.accessed = True\n\n        super().__init__(initial, on_update)\n\n    def __getitem__(self, key: str) -> t.Any:\n        self.accessed = True\n        return super().__getitem__(key)\n\n    def get(self, key: str, default: t.Any = None) -> t.Any:\n        self.accessed = True\n        return super().get(key, default)\n\n    def setdefault(self, key: str, default: t.Any = None) -> t.Any:\n        self.accessed = True\n        return super().setdefault(key, default)", "metadata": {"license": "BSD-3-Clause", "len_tokens": 412}, "prompt": "Write a Python class SecureCookieSession that inherits from both CallbackDict with generic types str and t.Any, and from SessionMixin. The class should track data access and modifications using two boolean class attributes: modified initially False, and accessed initially False. Implement an __init__ method that accepts an optional initial parameter (either a Mapping of str to Any, an Iterable of tuples, or None) and creates a nested callback function named on_update that sets both modified and accessed to True, then passes this initial data and callback to the parent CallbackDict constructor. Override three dictionary access methods: __getitem__, get, and setdefault - each should set accessed to True before calling the parent class method. Include a comprehensive class docstring explaining this is a base class for sessions based on signed cookies that tracks modified and accessed attributes but cannot reliably track new sessions. Add detailed comments for the modified and accessed attributes explaining when they are set and their purpose for cookie writing and Vary header. Import typing as t, collections.abc as c, and typing_extensions as te. Use te.Self for the callback function's self type hint. Output only code.", "notes": "Review and refine this prompt manually for fidelity."}
{"id": "flask:src/flask/sessions.py", "language": "python", "code": "class SecureCookieSessionInterface(SessionInterface):\n    \"\"\"The default session interface that stores sessions in signed cookies\n    through the :mod:`itsdangerous` module.\n    \"\"\"\n\n    #: the salt that should be applied on top of the secret key for the\n    #: signing of cookie based sessions.\n    salt = \"cookie-session\"\n    #: the hash function to use for the signature.  The default is sha1\n    digest_method = staticmethod(_lazy_sha1)\n    #: the name of the itsdangerous supported key derivation.  The default\n    #: is hmac.\n    key_derivation = \"hmac\"\n    #: A python serializer for the payload.  The default is a compact\n    #: JSON derived serializer with support for some extra Python types\n    #: such as datetime objects or tuples.\n    serializer = session_json_serializer\n    session_class = SecureCookieSession\n\n    def get_signing_serializer(self, app: Flask) -> URLSafeTimedSerializer | None:\n        if not app.secret_key:\n            return None\n\n        keys: list[str | bytes] = []\n\n        if fallbacks := app.config[\"SECRET_KEY_FALLBACKS\"]:\n            keys.extend(fallbacks)\n\n        keys.append(app.secret_key)  # itsdangerous expects current key at top\n        return URLSafeTimedSerializer(\n            keys,  # type: ignore[arg-type]\n            salt=self.salt,\n            serializer=self.serializer,\n            signer_kwargs={\n                \"key_derivation\": self.key_derivation,\n                \"digest_method\": self.digest_method,\n            },\n        )\n\n    def open_session(self, app: Flask, request: Request) -> SecureCookieSession | None:\n        s = self.get_signing_serializer(app)\n        if s is None:\n            return None\n        val = request.cookies.get(self.get_cookie_name(app))\n        if not val:\n            return self.session_class()\n        max_age = int(app.permanent_session_lifetime.total_seconds())\n        try:\n            data = s.loads(val, max_age=max_age)\n            return self.session_class(data)\n        except BadSignature:\n            return self.session_class()\n\n    def save_session(\n        self, app: Flask, session: SessionMixin, response: Response\n    ) -> None:\n        name = self.get_cookie_name(app)\n        domain = self.get_cookie_domain(app)\n        path = self.get_cookie_path(app)\n        secure = self.get_cookie_secure(app)\n        partitioned = self.get_cookie_partitioned(app)\n        samesite = self.get_cookie_samesite(app)\n        httponly = self.get_cookie_httponly(app)\n\n        # Add a \"Vary: Cookie\" header if the session was accessed at all.\n        if session.accessed:\n            response.vary.add(\"Cookie\")\n\n        # If the session is modified to be empty, remove the cookie.\n        # If the session is empty, return without setting the cookie.\n        if not session:\n            if session.modified:\n                response.delete_cookie(\n                    name,\n                    domain=domain,\n                    path=path,\n                    secure=secure,\n                    partitioned=partitioned,\n                    samesite=samesite,\n                    httponly=httponly,\n                )\n                response.vary.add(\"Cookie\")\n\n            return\n\n        if not self.should_set_cookie(app, session):\n            return\n\n        expires = self.get_expiration_time(app, session)\n        val = self.get_signing_serializer(app).dumps(dict(session))  # type: ignore[union-attr]\n        response.set_cookie(\n            name,\n            val,\n            expires=expires,\n            httponly=httponly,\n            domain=domain,\n            path=path,\n            secure=secure,\n            partitioned=partitioned,\n            samesite=samesite,\n        )\n        response.vary.add(\"Cookie\")", "metadata": {"license": "BSD-3-Clause", "len_tokens": 779}, "prompt": "Write a Python class SecureCookieSessionInterface inheriting from SessionInterface that stores sessions in signed cookies using the itsdangerous module. Define five class attributes: salt as string 'cookie-session', digest_method as a staticmethod reference to _lazy_sha1 function, key_derivation as string 'hmac', serializer as session_json_serializer, and session_class as SecureCookieSession. Implement get_signing_serializer method accepting a Flask app parameter that returns URLSafeTimedSerializer or None - if app has no secret_key return None, otherwise create a list of keys starting with any SECRET_KEY_FALLBACKS from app config then append the current app.secret_key, and return URLSafeTimedSerializer initialized with this keys list, salt attribute, serializer attribute, and signer_kwargs dict containing key_derivation and digest_method. Implement open_session method accepting app and request parameters that returns SecureCookieSession or None - call get_signing_serializer, if None return None, get cookie value using get_cookie_name method result, if no cookie value return empty session_class instance, calculate max_age as integer seconds from app.permanent_session_lifetime, try to load and deserialize cookie using serializer loads method with max_age parameter and return session_class with this data, catch BadSignature exception and return empty session_class. Implement save_session method accepting app, session, and response parameters - get cookie parameters using get_cookie_name, get_cookie_domain, get_cookie_path, get_cookie_secure, get_cookie_partitioned, get_cookie_samesite, get_cookie_httponly methods, if session.accessed add 'Cookie' to response.vary, if session is empty and modified delete the cookie using response.delete_cookie with all cookie parameters and add 'Cookie' to vary then return, if session is empty return without action, if should_set_cookie returns False return, otherwise get expiration time, serialize session dict using get_signing_serializer dumps method, set cookie using response.set_cookie with all parameters, and add 'Cookie' to vary. Include comprehensive class docstring and inline comments. Import Flask, Request, Response, SessionMixin, URLSafeTimedSerializer, BadSignature. Use type hints with union types for nullable returns. Output only code.", "notes": "Review and refine this prompt manually for fidelity."}
{"id": "flask:src/flask/sessions.py", "language": "python", "code": "def save_session(\n        self, app: Flask, session: SessionMixin, response: Response\n    ) -> None:\n        name = self.get_cookie_name(app)\n        domain = self.get_cookie_domain(app)\n        path = self.get_cookie_path(app)\n        secure = self.get_cookie_secure(app)\n        partitioned = self.get_cookie_partitioned(app)\n        samesite = self.get_cookie_samesite(app)\n        httponly = self.get_cookie_httponly(app)\n\n        # Add a \"Vary: Cookie\" header if the session was accessed at all.\n        if session.accessed:\n            response.vary.add(\"Cookie\")\n\n        # If the session is modified to be empty, remove the cookie.\n        # If the session is empty, return without setting the cookie.\n        if not session:\n            if session.modified:\n                response.delete_cookie(\n                    name,\n                    domain=domain,\n                    path=path,\n                    secure=secure,\n                    partitioned=partitioned,\n                    samesite=samesite,\n                    httponly=httponly,\n                )\n                response.vary.add(\"Cookie\")\n\n            return\n\n        if not self.should_set_cookie(app, session):\n            return\n\n        expires = self.get_expiration_time(app, session)\n        val = self.get_signing_serializer(app).dumps(dict(session))  # type: ignore[union-attr]\n        response.set_cookie(\n            name,\n            val,\n            expires=expires,\n            httponly=httponly,\n            domain=domain,\n            path=path,\n            secure=secure,\n            partitioned=partitioned,\n            samesite=samesite,\n        )\n        response.vary.add(\"Cookie\")", "metadata": {"license": "BSD-3-Clause", "len_tokens": 347}, "prompt": "Write a Python function `save_session(self, app, session, response)` that reproduces the intended behavior exactly, including edge cases and error handling. Use only the standard library. Keep the exact signature and names. Deterministic output, no prints or logs other than required. Add a concise docstring.\n\nDetails: [briefly specify behavior, inputs, outputs, constraints; no code]", "notes": "Review and refine this prompt manually for fidelity."}
{"id": "flask:src/flask/config.py", "language": "python", "code": "class ConfigAttribute(t.Generic[T]):\n    \"\"\"Makes an attribute forward to the config\"\"\"\n\n    def __init__(\n        self, name: str, get_converter: t.Callable[[t.Any], T] | None = None\n    ) -> None:\n        self.__name__ = name\n        self.get_converter = get_converter\n\n    @t.overload\n    def __get__(self, obj: None, owner: None) -> te.Self: ...\n\n    @t.overload\n    def __get__(self, obj: App, owner: type[App]) -> T: ...\n\n    def __get__(self, obj: App | None, owner: type[App] | None = None) -> T | te.Self:\n        if obj is None:\n            return self\n\n        rv = obj.config[self.__name__]\n\n        if self.get_converter is not None:\n            rv = self.get_converter(rv)\n\n        return rv  # type: ignore[no-any-return]\n\n    def __set__(self, obj: App, value: t.Any) -> None:\n        obj.config[self.__name__] = value", "metadata": {"license": "BSD-3-Clause", "len_tokens": 231}, "prompt": "Create a Python class `ConfigAttribute` implementing the same public API and behavior. Include methods: `__init__()`, `__get__()`, `__get__()`, `__get__()`, `__set__()`. Keep exact method names/signatures and deterministic behavior. Use only the standard library, no extra output. Provide minimal docstrings.\n\nDetails: [briefly specify behavior, inputs, outputs, constraints; no code]", "notes": "Review and refine this prompt manually for fidelity."}
{"id": "flask:src/flask/config.py", "language": "python", "code": "def from_envvar(self, variable_name: str, silent: bool = False) -> bool:\n        \"\"\"Loads a configuration from an environment variable pointing to\n        a configuration file.  This is basically just a shortcut with nicer\n        error messages for this line of code::\n\n            app.config.from_pyfile(os.environ['YOURAPPLICATION_SETTINGS'])\n\n        :param variable_name: name of the environment variable\n        :param silent: set to ``True`` if you want silent failure for missing\n                       files.\n        :return: ``True`` if the file was loaded successfully.\n        \"\"\"\n        rv = os.environ.get(variable_name)\n        if not rv:\n            if silent:\n                return False\n            raise RuntimeError(\n                f\"The environment variable {variable_name!r} is not set\"\n                \" and as such configuration could not be loaded. Set\"\n                \" this variable and make it point to a configuration\"\n                \" file\"\n            )\n        return self.from_pyfile(rv, silent=silent)", "metadata": {"license": "BSD-3-Clause", "len_tokens": 203}, "prompt": "Write a Python function `from_envvar(self, variable_name, silent)` that reproduces the intended behavior exactly, including edge cases and error handling. Use only the standard library. Keep the exact signature and names. Deterministic output, no prints or logs other than required. Add a concise docstring.\n\nDetails: [briefly specify behavior, inputs, outputs, constraints; no code]", "notes": "Review and refine this prompt manually for fidelity."}
{"id": "flask:src/flask/config.py", "language": "python", "code": "def from_prefixed_env(\n        self, prefix: str = \"FLASK\", *, loads: t.Callable[[str], t.Any] = json.loads\n    ) -> bool:\n        \"\"\"Load any environment variables that start with ``FLASK_``,\n        dropping the prefix from the env key for the config key. Values\n        are passed through a loading function to attempt to convert them\n        to more specific types than strings.\n\n        Keys are loaded in :func:`sorted` order.\n\n        The default loading function attempts to parse values as any\n        valid JSON type, including dicts and lists.\n\n        Specific items in nested dicts can be set by separating the\n        keys with double underscores (``__``). If an intermediate key\n        doesn't exist, it will be initialized to an empty dict.\n\n        :param prefix: Load env vars that start with this prefix,\n            separated with an underscore (``_``).\n        :param loads: Pass each string value to this function and use\n            the returned value as the config value. If any error is\n            raised it is ignored and the value remains a string. The\n            default is :func:`json.loads`.\n\n        .. versionadded:: 2.1\n        \"\"\"\n        prefix = f\"{prefix}_\"\n\n        for key in sorted(os.environ):\n            if not key.startswith(prefix):\n                continue\n\n            value = os.environ[key]\n            key = key.removeprefix(prefix)\n\n            try:\n                value = loads(value)\n            except Exception:\n                # Keep the value as a string if loading failed.\n                pass\n\n            if \"__\" not in key:\n                # A non-nested key, set directly.\n                self[key] = value\n                continue\n\n            # Traverse nested dictionaries with keys separated by \"__\".\n            current = self\n            *parts, tail = key.split(\"__\")\n\n            for part in parts:\n                # If an intermediate dict does not exist, create it.\n                if part not in current:\n                    current[part] = {}\n\n                current = current[part]\n\n            current[tail] = value\n\n        return True", "metadata": {"license": "BSD-3-Clause", "len_tokens": 431}, "prompt": "Write a Python function `from_prefixed_env(self, prefix, *, loads)` that reproduces the intended behavior exactly, including edge cases and error handling. Use only the standard library. Keep the exact signature and names. Deterministic output, no prints or logs other than required. Add a concise docstring.\n\nDetails: [briefly specify behavior, inputs, outputs, constraints; no code]", "notes": "Review and refine this prompt manually for fidelity."}
{"id": "flask:src/flask/config.py", "language": "python", "code": "def from_pyfile(\n        self, filename: str | os.PathLike[str], silent: bool = False\n    ) -> bool:\n        \"\"\"Updates the values in the config from a Python file.  This function\n        behaves as if the file was imported as module with the\n        :meth:`from_object` function.\n\n        :param filename: the filename of the config.  This can either be an\n                         absolute filename or a filename relative to the\n                         root path.\n        :param silent: set to ``True`` if you want silent failure for missing\n                       files.\n        :return: ``True`` if the file was loaded successfully.\n\n        .. versionadded:: 0.7\n           `silent` parameter.\n        \"\"\"\n        filename = os.path.join(self.root_path, filename)\n        d = types.ModuleType(\"config\")\n        d.__file__ = filename\n        try:\n            with open(filename, mode=\"rb\") as config_file:\n                exec(compile(config_file.read(), filename, \"exec\"), d.__dict__)\n        except OSError as e:\n            if silent and e.errno in (errno.ENOENT, errno.EISDIR, errno.ENOTDIR):\n                return False\n            e.strerror = f\"Unable to load configuration file ({e.strerror})\"\n            raise\n        self.from_object(d)\n        return True", "metadata": {"license": "BSD-3-Clause", "len_tokens": 279}, "prompt": "Write a Python function `from_pyfile(self, filename, silent)` that reproduces the intended behavior exactly, including edge cases and error handling. Use only the standard library. Keep the exact signature and names. Deterministic output, no prints or logs other than required. Add a concise docstring.\n\nDetails: [briefly specify behavior, inputs, outputs, constraints; no code]", "notes": "Review and refine this prompt manually for fidelity."}
{"id": "flask:src/flask/config.py", "language": "python", "code": "def from_object(self, obj: object | str) -> None:\n        \"\"\"Updates the values from the given object.  An object can be of one\n        of the following two types:\n\n        -   a string: in this case the object with that name will be imported\n        -   an actual object reference: that object is used directly\n\n        Objects are usually either modules or classes. :meth:`from_object`\n        loads only the uppercase attributes of the module/class. A ``dict``\n        object will not work with :meth:`from_object` because the keys of a\n        ``dict`` are not attributes of the ``dict`` class.\n\n        Example of module-based configuration::\n\n            app.config.from_object('yourapplication.default_config')\n            from yourapplication import default_config\n            app.config.from_object(default_config)\n\n        Nothing is done to the object before loading. If the object is a\n        class and has ``@property`` attributes, it needs to be\n        instantiated before being passed to this method.\n\n        You should not use this function to load the actual configuration but\n        rather configuration defaults.  The actual config should be loaded\n        with :meth:`from_pyfile` and ideally from a location not within the\n        package because the package might be installed system wide.\n\n        See :ref:`config-dev-prod` for an example of class-based configuration\n        using :meth:`from_object`.\n\n        :param obj: an import name or object\n        \"\"\"\n        if isinstance(obj, str):\n            obj = import_string(obj)\n        for key in dir(obj):\n            if key.isupper():\n                self[key] = getattr(obj, key)", "metadata": {"license": "BSD-3-Clause", "len_tokens": 339}, "prompt": "Write a Python function `from_object(self, obj)` that reproduces the intended behavior exactly, including edge cases and error handling. Use only the standard library. Keep the exact signature and names. Deterministic output, no prints or logs other than required. Add a concise docstring.\n\nDetails: [briefly specify behavior, inputs, outputs, constraints; no code]", "notes": "Review and refine this prompt manually for fidelity."}
{"id": "flask:src/flask/config.py", "language": "python", "code": "def from_file(\n        self,\n        filename: str | os.PathLike[str],\n        load: t.Callable[[t.IO[t.Any]], t.Mapping[str, t.Any]],\n        silent: bool = False,\n        text: bool = True,\n    ) -> bool:\n        \"\"\"Update the values in the config from a file that is loaded\n        using the ``load`` parameter. The loaded data is passed to the\n        :meth:`from_mapping` method.\n\n        .. code-block:: python\n\n            import json\n            app.config.from_file(\"config.json\", load=json.load)\n\n            import tomllib\n            app.config.from_file(\"config.toml\", load=tomllib.load, text=False)\n\n        :param filename: The path to the data file. This can be an\n            absolute path or relative to the config root path.\n        :param load: A callable that takes a file handle and returns a\n            mapping of loaded data from the file.\n        :type load: ``Callable[[Reader], Mapping]`` where ``Reader``\n            implements a ``read`` method.\n        :param silent: Ignore the file if it doesn't exist.\n        :param text: Open the file in text or binary mode.\n        :return: ``True`` if the file was loaded successfully.\n\n        .. versionchanged:: 2.3\n            The ``text`` parameter was added.\n\n        .. versionadded:: 2.0\n        \"\"\"\n        filename = os.path.join(self.root_path, filename)\n\n        try:\n            with open(filename, \"r\" if text else \"rb\") as f:\n                obj = load(f)\n        except OSError as e:\n            if silent and e.errno in (errno.ENOENT, errno.EISDIR):\n                return False\n\n            e.strerror = f\"Unable to load configuration file ({e.strerror})\"\n            raise\n\n        return self.from_mapping(obj)", "metadata": {"license": "BSD-3-Clause", "len_tokens": 390}, "prompt": "Write a Python function `from_file(self, filename, load, silent, text)` that reproduces the intended behavior exactly, including edge cases and error handling. Use only the standard library. Keep the exact signature and names. Deterministic output, no prints or logs other than required. Add a concise docstring.\n\nDetails: [briefly specify behavior, inputs, outputs, constraints; no code]", "notes": "Review and refine this prompt manually for fidelity."}
{"id": "flask:src/flask/config.py", "language": "python", "code": "def get_namespace(\n        self, namespace: str, lowercase: bool = True, trim_namespace: bool = True\n    ) -> dict[str, t.Any]:\n        \"\"\"Returns a dictionary containing a subset of configuration options\n        that match the specified namespace/prefix. Example usage::\n\n            app.config['IMAGE_STORE_TYPE'] = 'fs'\n            app.config['IMAGE_STORE_PATH'] = '/var/app/images'\n            app.config['IMAGE_STORE_BASE_URL'] = 'http://img.website.com'\n            image_store_config = app.config.get_namespace('IMAGE_STORE_')\n\n        The resulting dictionary `image_store_config` would look like::\n\n            {\n                'type': 'fs',\n                'path': '/var/app/images',\n                'base_url': 'http://img.website.com'\n            }\n\n        This is often useful when configuration options map directly to\n        keyword arguments in functions or class constructors.\n\n        :param namespace: a configuration namespace\n        :param lowercase: a flag indicating if the keys of the resulting\n                          dictionary should be lowercase\n        :param trim_namespace: a flag indicating if the keys of the resulting\n                          dictionary should not include the namespace\n\n        .. versionadded:: 0.11\n        \"\"\"\n        rv = {}\n        for k, v in self.items():\n            if not k.startswith(namespace):\n                continue\n            if trim_namespace:\n                key = k[len(namespace) :]\n            else:\n                key = k\n            if lowercase:\n                key = key.lower()\n            rv[key] = v\n        return rv", "metadata": {"license": "BSD-3-Clause", "len_tokens": 310}, "prompt": "Write a Python function `get_namespace(self, namespace, lowercase, trim_namespace)` that reproduces the intended behavior exactly, including edge cases and error handling. Use only the standard library. Keep the exact signature and names. Deterministic output, no prints or logs other than required. Add a concise docstring.\n\nDetails: [briefly specify behavior, inputs, outputs, constraints; no code]", "notes": "Review and refine this prompt manually for fidelity."}
{"id": "flask:src/flask/templating.py", "language": "python", "code": "class DispatchingJinjaLoader(BaseLoader):\n    \"\"\"A loader that looks for templates in the application and all\n    the blueprint folders.\n    \"\"\"\n\n    def __init__(self, app: App) -> None:\n        self.app = app\n\n    def get_source(\n        self, environment: BaseEnvironment, template: str\n    ) -> tuple[str, str | None, t.Callable[[], bool] | None]:\n        if self.app.config[\"EXPLAIN_TEMPLATE_LOADING\"]:\n            return self._get_source_explained(environment, template)\n        return self._get_source_fast(environment, template)\n\n    def _get_source_explained(\n        self, environment: BaseEnvironment, template: str\n    ) -> tuple[str, str | None, t.Callable[[], bool] | None]:\n        attempts = []\n        rv: tuple[str, str | None, t.Callable[[], bool] | None] | None\n        trv: None | (tuple[str, str | None, t.Callable[[], bool] | None]) = None\n\n        for srcobj, loader in self._iter_loaders(template):\n            try:\n                rv = loader.get_source(environment, template)\n                if trv is None:\n                    trv = rv\n            except TemplateNotFound:\n                rv = None\n            attempts.append((loader, srcobj, rv))\n\n        from .debughelpers import explain_template_loading_attempts\n\n        explain_template_loading_attempts(self.app, template, attempts)\n\n        if trv is not None:\n            return trv\n        raise TemplateNotFound(template)\n\n    def _get_source_fast(\n        self, environment: BaseEnvironment, template: str\n    ) -> tuple[str, str | None, t.Callable[[], bool] | None]:\n        for _srcobj, loader in self._iter_loaders(template):\n            try:\n                return loader.get_source(environment, template)\n            except TemplateNotFound:\n                continue\n        raise TemplateNotFound(template)\n\n    def _iter_loaders(self, template: str) -> t.Iterator[tuple[Scaffold, BaseLoader]]:\n        loader = self.app.jinja_loader\n        if loader is not None:\n            yield self.app, loader\n\n        for blueprint in self.app.iter_blueprints():\n            loader = blueprint.jinja_loader\n            if loader is not None:\n                yield blueprint, loader\n\n    def list_templates(self) -> list[str]:\n        result = set()\n        loader = self.app.jinja_loader\n        if loader is not None:\n            result.update(loader.list_templates())\n\n        for blueprint in self.app.iter_blueprints():\n            loader = blueprint.jinja_loader\n            if loader is not None:\n                for template in loader.list_templates():\n                    result.add(template)\n\n        return list(result)", "metadata": {"license": "BSD-3-Clause", "len_tokens": 566}, "prompt": "Create a Python class `DispatchingJinjaLoader` implementing the same public API and behavior. Include methods: `__init__()`, `get_source()`, `_get_source_explained()`, `_get_source_fast()`, `_iter_loaders()`, `list_templates()`. Keep exact method names/signatures and deterministic behavior. Use only the standard library, no extra output. Provide minimal docstrings.\n\nDetails: [briefly specify behavior, inputs, outputs, constraints; no code]", "notes": "Review and refine this prompt manually for fidelity."}
{"id": "flask:src/flask/templating.py", "language": "python", "code": "def _get_source_explained(\n        self, environment: BaseEnvironment, template: str\n    ) -> tuple[str, str | None, t.Callable[[], bool] | None]:\n        attempts = []\n        rv: tuple[str, str | None, t.Callable[[], bool] | None] | None\n        trv: None | (tuple[str, str | None, t.Callable[[], bool] | None]) = None\n\n        for srcobj, loader in self._iter_loaders(template):\n            try:\n                rv = loader.get_source(environment, template)\n                if trv is None:\n                    trv = rv\n            except TemplateNotFound:\n                rv = None\n            attempts.append((loader, srcobj, rv))\n\n        from .debughelpers import explain_template_loading_attempts\n\n        explain_template_loading_attempts(self.app, template, attempts)\n\n        if trv is not None:\n            return trv\n        raise TemplateNotFound(template)", "metadata": {"license": "BSD-3-Clause", "len_tokens": 201}, "prompt": "Write a Python function `_get_source_explained(self, environment, template)` that reproduces the intended behavior exactly, including edge cases and error handling. Use only the standard library. Keep the exact signature and names. Deterministic output, no prints or logs other than required. Add a concise docstring.\n\nDetails: [briefly specify behavior, inputs, outputs, constraints; no code]", "notes": "Review and refine this prompt manually for fidelity."}
{"id": "flask:src/flask/globals.py", "language": "python", "code": "from __future__ import annotations\n\nimport typing as t\nfrom contextvars import ContextVar\n\nfrom werkzeug.local import LocalProxy\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from .app import Flask\n    from .ctx import _AppCtxGlobals\n    from .ctx import AppContext\n    from .sessions import SessionMixin\n    from .wrappers import Request\n\n    T = t.TypeVar(\"T\", covariant=True)\n\n    class ProxyMixin(t.Protocol[T]):\n        def _get_current_object(self) -> T: ...\n\n    # These subclasses inform type checkers that the proxy objects look like the\n    # proxied type along with the _get_current_object method.\n    class FlaskProxy(ProxyMixin[Flask], Flask): ...\n\n    class AppContextProxy(ProxyMixin[AppContext], AppContext): ...\n\n    class _AppCtxGlobalsProxy(ProxyMixin[_AppCtxGlobals], _AppCtxGlobals): ...\n\n    class RequestProxy(ProxyMixin[Request], Request): ...\n\n    class SessionMixinProxy(ProxyMixin[SessionMixin], SessionMixin): ...\n\n\n_no_app_msg = \"\"\"\\\nWorking outside of application context.\n\nAttempted to use functionality that expected a current application to be set. To\nsolve this, set up an app context using 'with app.app_context()'. See the\ndocumentation on app context for more information.\\\n\"\"\"\n_cv_app: ContextVar[AppContext] = ContextVar(\"flask.app_ctx\")\napp_ctx: AppContextProxy = LocalProxy(  # type: ignore[assignment]\n    _cv_app, unbound_message=_no_app_msg\n)\ncurrent_app: FlaskProxy = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"app\", unbound_message=_no_app_msg\n)\ng: _AppCtxGlobalsProxy = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"g\", unbound_message=_no_app_msg\n)\n\n_no_req_msg = \"\"\"\\\nWorking outside of request context.\n\nAttempted to use functionality that expected an active HTTP request. See the\ndocumentation on request context for more information.\\\n\"\"\"\nrequest: RequestProxy = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"request\", unbound_message=_no_req_msg\n)\nsession: SessionMixinProxy = LocalProxy(  # type: ignore[assignment]\n    _cv_app, \"session\", unbound_message=_no_req_msg\n)\n\n\ndef __getattr__(name: str) -> t.Any:\n    import warnings\n\n    if name == \"request_ctx\":\n        warnings.warn(\n            \"'request_ctx' has merged with 'app_ctx', and will be removed\"\n            \" in Flask 4.0. Use 'app_ctx' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return app_ctx\n\n    raise AttributeError(name)\n", "metadata": {"license": "BSD-3-Clause", "len_tokens": 592}, "prompt": "Write a Python function `__getattr__(name)` that reproduces the intended behavior exactly, including edge cases and error handling. Use only the standard library. Keep the exact signature and names. Deterministic output, no prints or logs other than required. Add a concise docstring.\n\nDetails: [briefly specify behavior, inputs, outputs, constraints; no code]", "notes": "Review and refine this prompt manually for fidelity."}
{"id": "flask:src/flask/__init__.py", "language": "python", "code": "from . import json as json\nfrom .app import Flask as Flask\nfrom .blueprints import Blueprint as Blueprint\nfrom .config import Config as Config\nfrom .ctx import after_this_request as after_this_request\nfrom .ctx import copy_current_request_context as copy_current_request_context\nfrom .ctx import has_app_context as has_app_context\nfrom .ctx import has_request_context as has_request_context\nfrom .globals import current_app as current_app\nfrom .globals import g as g\nfrom .globals import request as request\nfrom .globals import session as session\nfrom .helpers import abort as abort\nfrom .helpers import flash as flash\nfrom .helpers import get_flashed_messages as get_flashed_messages\nfrom .helpers import get_template_attribute as get_template_attribute\nfrom .helpers import make_response as make_response\nfrom .helpers import redirect as redirect\nfrom .helpers import send_file as send_file\nfrom .helpers import send_from_directory as send_from_directory\nfrom .helpers import stream_with_context as stream_with_context\nfrom .helpers import url_for as url_for\nfrom .json import jsonify as jsonify\nfrom .signals import appcontext_popped as appcontext_popped\nfrom .signals import appcontext_pushed as appcontext_pushed\nfrom .signals import appcontext_tearing_down as appcontext_tearing_down\nfrom .signals import before_render_template as before_render_template\nfrom .signals import got_request_exception as got_request_exception\nfrom .signals import message_flashed as message_flashed\nfrom .signals import request_finished as request_finished\nfrom .signals import request_started as request_started\nfrom .signals import request_tearing_down as request_tearing_down\nfrom .signals import template_rendered as template_rendered\nfrom .templating import render_template as render_template\nfrom .templating import render_template_string as render_template_string\nfrom .templating import stream_template as stream_template\nfrom .templating import stream_template_string as stream_template_string\nfrom .wrappers import Request as Request\nfrom .wrappers import Response as Response\n", "metadata": {"license": "BSD-3-Clause", "len_tokens": 424}, "prompt": "Implement the described Python module deterministically with the required API. Keep names and behavior exact; do not add extraneous text.\n\nDetails: [briefly specify behavior, inputs, outputs, constraints; no code]", "notes": "Review and refine this prompt manually for fidelity."}
{"id": "flask:src/flask/blueprints.py", "language": "python", "code": "def __init__(\n        self,\n        name: str,\n        import_name: str,\n        static_folder: str | os.PathLike[str] | None = None,\n        static_url_path: str | None = None,\n        template_folder: str | os.PathLike[str] | None = None,\n        url_prefix: str | None = None,\n        subdomain: str | None = None,\n        url_defaults: dict[str, t.Any] | None = None,\n        root_path: str | None = None,\n        cli_group: str | None = _sentinel,  # type: ignore\n    ) -> None:\n        super().__init__(\n            name,\n            import_name,\n            static_folder,\n            static_url_path,\n            template_folder,\n            url_prefix,\n            subdomain,\n            url_defaults,\n            root_path,\n            cli_group,\n        )\n\n        #: The Click command group for registering CLI commands for this\n        #: object. The commands are available from the ``flask`` command\n        #: once the application has been discovered and blueprints have\n        #: been registered.\n        self.cli = AppGroup()\n\n        # Set the name of the Click group in case someone wants to add\n        # the app's commands to another CLI tool.\n        self.cli.name = self.name", "metadata": {"license": "BSD-3-Clause", "len_tokens": 264}, "prompt": "Write a Python function `__init__(self, name, import_name, static_folder, static_url_path, template_folder, url_prefix, subdomain, url_defaults, root_path, cli_group)` that reproduces the intended behavior exactly, including edge cases and error handling. Use only the standard library. Keep the exact signature and names. Deterministic output, no prints or logs other than required. Add a concise docstring.\n\nDetails: [briefly specify behavior, inputs, outputs, constraints; no code]", "notes": "Review and refine this prompt manually for fidelity."}
{"id": "flask:src/flask/blueprints.py", "language": "python", "code": "def get_send_file_max_age(self, filename: str | None) -> int | None:\n        \"\"\"Used by :func:`send_file` to determine the ``max_age`` cache\n        value for a given file path if it wasn't passed.\n\n        By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from\n        the configuration of :data:`~flask.current_app`. This defaults\n        to ``None``, which tells the browser to use conditional requests\n        instead of a timed cache, which is usually preferable.\n\n        Note this is a duplicate of the same method in the Flask\n        class.\n\n        .. versionchanged:: 2.0\n            The default configuration is ``None`` instead of 12 hours.\n\n        .. versionadded:: 0.9\n        \"\"\"\n        value = current_app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n\n        if value is None:\n            return None\n\n        if isinstance(value, timedelta):\n            return int(value.total_seconds())\n\n        return value", "metadata": {"license": "BSD-3-Clause", "len_tokens": 205}, "prompt": "Write a Python function `get_send_file_max_age(self, filename)` that reproduces the intended behavior exactly, including edge cases and error handling. Use only the standard library. Keep the exact signature and names. Deterministic output, no prints or logs other than required. Add a concise docstring.\n\nDetails: [briefly specify behavior, inputs, outputs, constraints; no code]", "notes": "Review and refine this prompt manually for fidelity."}
{"id": "flask:src/flask/blueprints.py", "language": "python", "code": "def open_resource(\n        self, resource: str, mode: str = \"rb\", encoding: str | None = \"utf-8\"\n    ) -> t.IO[t.AnyStr]:\n        \"\"\"Open a resource file relative to :attr:`root_path` for reading. The\n        blueprint-relative equivalent of the app's :meth:`~.Flask.open_resource`\n        method.\n\n        :param resource: Path to the resource relative to :attr:`root_path`.\n        :param mode: Open the file in this mode. Only reading is supported,\n            valid values are ``\"r\"`` (or ``\"rt\"``) and ``\"rb\"``.\n        :param encoding: Open the file with this encoding when opening in text\n            mode. This is ignored when opening in binary mode.\n\n        .. versionchanged:: 3.1\n            Added the ``encoding`` parameter.\n        \"\"\"\n        if mode not in {\"r\", \"rt\", \"rb\"}:\n            raise ValueError(\"Resources can only be opened for reading.\")\n\n        path = os.path.join(self.root_path, resource)\n\n        if mode == \"rb\":\n            return open(path, mode)  # pyright: ignore\n\n        return open(path, mode, encoding=encoding)", "metadata": {"license": "BSD-3-Clause", "len_tokens": 256}, "prompt": "Write a Python function `open_resource(self, resource, mode, encoding)` that reproduces the intended behavior exactly, including edge cases and error handling. Use only the standard library. Keep the exact signature and names. Deterministic output, no prints or logs other than required. Add a concise docstring.\n\nDetails: [briefly specify behavior, inputs, outputs, constraints; no code]", "notes": "Review and refine this prompt manually for fidelity."}
{"id": "flask:src/flask/cli.py", "language": "python", "code": "def find_best_app(module: ModuleType) -> Flask:\n    \"\"\"Given a module instance this tries to find the best possible\n    application in the module or raises an exception.\n    \"\"\"\n    from . import Flask\n\n    # Search for the most common names first.\n    for attr_name in (\"app\", \"application\"):\n        app = getattr(module, attr_name, None)\n\n        if isinstance(app, Flask):\n            return app\n\n    # Otherwise find the only object that is a Flask instance.\n    matches = [v for v in module.__dict__.values() if isinstance(v, Flask)]\n\n    if len(matches) == 1:\n        return matches[0]\n    elif len(matches) > 1:\n        raise NoAppException(\n            \"Detected multiple Flask applications in module\"\n            f\" '{module.__name__}'. Use '{module.__name__}:name'\"\n            \" to specify the correct one.\"\n        )\n\n    # Search for app factory functions.\n    for attr_name in (\"create_app\", \"make_app\"):\n        app_factory = getattr(module, attr_name, None)\n\n        if inspect.isfunction(app_factory):\n            try:\n                app = app_factory()\n\n                if isinstance(app, Flask):\n                    return app\n            except TypeError as e:\n                if not _called_with_wrong_args(app_factory):\n                    raise\n\n                raise NoAppException(\n                    f\"Detected factory '{attr_name}' in module '{module.__name__}',\"\n                    \" but could not call it without arguments. Use\"\n                    f\" '{module.__name__}:{attr_name}(args)'\"\n                    \" to specify arguments.\"\n                ) from e\n\n    raise NoAppException(\n        \"Failed to find Flask application or factory in module\"\n        f\" '{module.__name__}'. Use '{module.__name__}:name'\"\n        \" to specify one.\"\n    )", "metadata": {"license": "BSD-3-Clause", "len_tokens": 375}, "prompt": "Write a Python function `find_best_app(module)` that reproduces the intended behavior exactly, including edge cases and error handling. Use only the standard library. Keep the exact signature and names. Deterministic output, no prints or logs other than required. Add a concise docstring.\n\nDetails: [briefly specify behavior, inputs, outputs, constraints; no code]", "notes": "Review and refine this prompt manually for fidelity."}