{"id": "flask:src/flask/logging.py", "prompt": "In a WSGI-based Python web application, the logging subsystem needs a reliable way to obtain an error output stream. When a request context is active, error output should be routed to the request-specific error stream provided by the WSGI environment. Outside of an active request, a sensible process-level fallback should be used. The resulting utility must integrate cleanly with standard logging handlers and behave correctly in both request-bound and request-free execution paths. ", "target_code": "from __future__ import annotations\n\nimport logging\nimport sys\nimport typing as t\n\nfrom werkzeug.local import LocalProxy\n\nfrom .globals import request\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from .sansio.app import App\n\n\n@LocalProxy\ndef wsgi_errors_stream() -> t.TextIO:\n    \"\"\"Find the most appropriate error stream for the application. If a request\n    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\n    If you configure your own :class:`logging.StreamHandler`, you may want to\n    use this for the stream. If you are using file or dict configuration and\n    can't import this directly, you can refer to it as\n    ``ext://flask.logging.wsgi_errors_stream``.\n    \"\"\"\n    if request:\n        return request.environ[\"wsgi.errors\"]  # type: ignore[no-any-return]\n\n    return sys.stderr\n\n\ndef has_level_handler(logger: logging.Logger) -> bool:\n    \"\"\"Check if there is a handler in the logging chain that will handle the\n    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n    \"\"\"\n    level = logger.getEffectiveLevel()\n    current = logger\n\n    while current:\n        if any(handler.level <= level for handler in current.handlers):\n            return True\n\n        if not current.propagate:\n            break\n\n        current = current.parent  # type: ignore\n\n    return False\n\n\n#: Log messages to :func:`~flask.logging.wsgi_errors_stream` with the format\n#: ``[%(asctime)s] %(levelname)s in %(module)s: %(message)s``.\ndefault_handler = logging.StreamHandler(wsgi_errors_stream)  # type: ignore\ndefault_handler.setFormatter(\n    logging.Formatter(\"[%(asctime)s] %(levelname)s in %(module)s: %(message)s\")\n)\n\n\ndef create_logger(app: App) -> logging.Logger:\n    \"\"\"Get the Flask app's logger and configure it if needed.\n\n    The logger name will be the same as\n    :attr:`app.import_name <flask.Flask.name>`.\n\n    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n    :data:`logging.DEBUG` if it is not set.\n\n    If there is no handler for the logger's effective level, add a\n    :class:`~logging.StreamHandler` for\n    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n    \"\"\"\n    logger = logging.getLogger(app.name)\n\n    if app.debug and not logger.level:\n        logger.setLevel(logging.DEBUG)\n\n    if not has_level_handler(logger):\n        logger.addHandler(default_handler)\n\n    return logger\n", "generated_code": "We need to produce a solution: a utility that obtains an error output stream for logging in a WSGI-based Python web app. When request context active, use request-specific error stream from WSGI env. Outside request, fallback to process-level stream (e.g., sys.stderr). It should integrate with standard logging handlers and behave correctly in both contexts.\n\nWe need to explain design, maybe provide code: a context manager or function that returns a stream. Use contextvars or thread-local to store request context. In WSGI, the environ dict contains 'wsgi.errors' stream. So we can create a function get_error_stream() that checks if request context is active: maybe using a context variable that holds environ. If active, return environ['wsgi.errors']; else return sys.stderr.\n\nAlso integrate with logging: create a logging.Handler subclass that writes to the stream returned by get_error_stream. Or use logging.StreamHandler with a custom stream provider.\n\nWe need to ensure thread safety: WSGI may run in multi-threaded or multi-process. Use contextvars for request context.\n\nAlso provide example usage: in WSGI app, set context variable at start of request, clear at end. Or use a decorator.\n\nAlso mention fallback: sys.stderr or logging.StreamHandler to sys.stderr.\n\nAlso mention that the utility should be used by logging handlers: e.g., create a handler that uses get_error_stream() each time it emits.\n\nAlso mention that the fallback should be process-level: maybe use a global default stream.\n\nAlso mention that the utility should be robust: if environ missing 'wsgi.errors', fallback.\n\nAlso mention that the request context may be stored in a thread-local variable or contextvar.\n\nAlso mention that the utility should be used in both request-bound and request-free contexts: e.g., background tasks.\n\nAlso mention that the logging handler should be configured to use this stream.\n\nAlso mention that we can use logging.handlers.QueueHandler or other.\n\nAlso mention that we can use a custom handler that obtains stream on each emit.\n\nAlso mention that we can use logging.StreamHandler with a custom stream that is a proxy to get_error_stream.\n\nAlso mention that we can use a wrapper class that implements file-like interface and delegates to get_error_stream.\n\nAlso mention that we can use contextvars to store environ.\n\nAlso mention that we can use a context manager to set environ.\n\nAlso mention that we can use a decorator to wrap WSGI app.\n\nAlso mention that we can use a middleware to set context.\n\nAlso mention that", "L_val": 0.6152038397802856, "quality_passed": false, "length_constraint_passed": false, "ast_equal": false, "similarity": 0.029747351263243682, "prompt_token_len": 90, "target_token_len": 566, "generated_token_len": 509, "latency_sec": 8.70773115567863, "backend": "vllm", "temperature": 0.0, "top_p": 1.0, "top_k": null, "seed": 0, "max_new_tokens": 512, "quality_threshold": 0.1, "length_factor": 0.15}
{"id": "flask:src/flask/sessions.py", "prompt": "When handling an outgoing HTTP response, the session subsystem must decide whether session data should be persisted, updated, or removed from the client. If a session was accessed, appropriate response headers should be adjusted. Empty sessions that were modified should result in removal of the corresponding cookie, while non-empty sessions may be serialized and stored according to application configuration and expiration rules. ", "target_code": "class SessionMixin(MutableMapping[str, t.Any]):\n    \"\"\"Expands a basic dictionary with session attributes.\"\"\"\n\n    @property\n    def permanent(self) -> bool:\n        \"\"\"This reflects the ``'_permanent'`` key in the dict.\"\"\"\n        return self.get(\"_permanent\", False)  # type: ignore[no-any-return]\n\n    @permanent.setter\n    def permanent(self, value: bool) -> None:\n        self[\"_permanent\"] = bool(value)\n\n    #: Some implementations can detect whether a session is newly\n    #: created, but that is not guaranteed. Use with caution. The mixin\n    # default is hard-coded ``False``.\n    new = False\n\n    #: Some implementations can detect changes to the session and set\n    #: this when that happens. The mixin default is hard coded to\n    #: ``True``.\n    modified = True\n\n    #: Some implementations can detect when session data is read or\n    #: written and set this when that happens. The mixin default is hard\n    #: coded to ``True``.\n    accessed = True", "generated_code": "The user gave a description of a requirement: \"When handling an outgoing HTTP response, the session subsystem must decide whether session data should be persisted, updated, or removed from the client. If a session was accessed, appropriate response headers should be adjusted. Empty sessions that were modified should result in removal of the corresponding cookie, while non-empty sessions may be serialized and stored according to application configuration and expiration rules.\"\n\nThey likely want a code snippet or explanation of how to implement this logic. The user didn't ask a direct question, but gave a description. They might want a code example in a particular language? The context: \"When handling an outgoing HTTP response, the session subsystem must decide whether session data should be persisted, updated, or removed from the client.\" This is a design requirement. They might want a design or algorithm. The user didn't specify language. Could be generic pseudocode. They might want a detailed explanation of how to handle session persistence, cookie removal, etc.\n\nWe should respond with a clear explanation of the logic, maybe pseudocode, and mention key points: check if session accessed, if modified, if empty, remove cookie, else serialize and set cookie with expiration. Also mention how to adjust response headers: Set-Cookie, maybe Delete-Cookie. Also mention application config: session store, expiration, secure, httpOnly, sameSite. Also mention how to handle session removal: delete from store, remove cookie.\n\nWe can provide a sample implementation in a language like Node.js/Express, Python/Flask, Java/Spring, or generic pseudocode. The user didn't specify, so we can give a generic approach and optionally show examples in a few languages.\n\nWe should also mention that the session subsystem should be invoked after request handling but before sending response. It should check session state: accessed, modified, empty. If accessed, set appropriate headers: maybe Set-Cookie with updated expiration. If empty and modified, remove cookie: Set-Cookie with Max-Age=0 or Expires in past. If non-empty, serialize and store: maybe in database or memory, then set cookie with session ID.\n\nAlso mention that if session is not accessed, no changes to headers.\n\nWe can also mention that the session ID cookie should be set with secure flags.\n\nWe can also mention that the session subsystem should handle concurrency, expiration, etc.\n\nWe can also mention that the session store may be in-memory, database, Redis, etc.\n\nWe can also mention that the session subsystem may need to handle session regeneration.\n\nWe can", "L_val": 0.42529836078676153, "quality_passed": false, "length_constraint_passed": false, "ast_equal": false, "similarity": 0.014452473596442469, "prompt_token_len": 72, "target_token_len": 225, "generated_token_len": 509, "latency_sec": 5.936730666086078, "backend": "vllm", "temperature": 0.0, "top_p": 1.0, "top_k": null, "seed": 0, "max_new_tokens": 512, "quality_threshold": 0.1, "length_factor": 0.15}
{"id": "flask:src/flask/sessions.py", "prompt": "When handling an outgoing HTTP response, the session subsystem must decide whether session data should be persisted, updated, or removed from the client. If a session was accessed, appropriate response headers should be adjusted. Empty sessions that were modified should result in removal of the corresponding cookie, while non-empty sessions may be serialized and stored according to application configuration and expiration rules. ", "target_code": "class SecureCookieSession(CallbackDict[str, t.Any], SessionMixin):\n    \"\"\"Base class for sessions based on signed cookies.\n\n    This session backend will set the :attr:`modified` and\n    :attr:`accessed` attributes. It cannot reliably track whether a\n    session is new (vs. empty), so :attr:`new` remains hard coded to\n    ``False``.\n    \"\"\"\n\n    #: When data is changed, this is set to ``True``. Only the session\n    #: dictionary itself is tracked; if the session contains mutable\n    #: data (for example a nested dict) then this must be set to\n    #: ``True`` manually when modifying that data. The session cookie\n    #: will only be written to the response if this is ``True``.\n    modified = False\n\n    #: When data is read or written, this is set to ``True``. Used by\n    # :class:`.SecureCookieSessionInterface` to add a ``Vary: Cookie``\n    #: header, which allows caching proxies to cache different pages for\n    #: different users.\n    accessed = False\n\n    def __init__(\n        self,\n        initial: c.Mapping[str, t.Any] | c.Iterable[tuple[str, t.Any]] | None = None,\n    ) -> None:\n        def on_update(self: te.Self) -> None:\n            self.modified = True\n            self.accessed = True\n\n        super().__init__(initial, on_update)\n\n    def __getitem__(self, key: str) -> t.Any:\n        self.accessed = True\n        return super().__getitem__(key)\n\n    def get(self, key: str, default: t.Any = None) -> t.Any:\n        self.accessed = True\n        return super().get(key, default)\n\n    def setdefault(self, key: str, default: t.Any = None) -> t.Any:\n        self.accessed = True\n        return super().setdefault(key, default)", "generated_code": "The user gave a description of a requirement: \"When handling an outgoing HTTP response, the session subsystem must decide whether session data should be persisted, updated, or removed from the client. If a session was accessed, appropriate response headers should be adjusted. Empty sessions that were modified should result in removal of the corresponding cookie, while non-empty sessions may be serialized and stored according to application configuration and expiration rules.\"\n\nThey likely want a code snippet or explanation of how to implement this logic. The user didn't ask a direct question, but gave a description. They might want a code example in a particular language? The context: \"When handling an outgoing HTTP response, the session subsystem must decide whether session data should be persisted, updated, or removed from the client.\" This is a design requirement. They might want a design or algorithm. The user didn't specify language. Could be generic pseudocode. They might want a detailed explanation of how to handle session persistence, cookie removal, etc.\n\nWe should respond with a clear explanation of the logic, maybe pseudocode, and mention key points: check if session accessed, if modified, if empty, remove cookie, else serialize and set cookie with expiration. Also mention how to adjust response headers: Set-Cookie, maybe Delete-Cookie. Also mention application config: session store, expiration, secure, httpOnly, sameSite. Also mention how to handle session removal: delete from store, remove cookie.\n\nWe can provide a sample implementation in a language like Node.js/Express, Python/Flask, Java/Spring, or generic pseudocode. The user didn't specify, so we can give a generic approach and optionally show examples in a few languages.\n\nWe should also mention that the session subsystem should be invoked after request handling but before sending response. It should check session state: accessed, modified, empty. If accessed, set appropriate headers: maybe Set-Cookie with updated expiration. If empty and modified, remove cookie: Set-Cookie with Max-Age=0 or Expires in past. If non-empty, serialize and store: maybe in database or memory, then set cookie with session ID.\n\nAlso mention that if session is not accessed, no changes to headers.\n\nWe can also mention that the session ID cookie should be set with secure flags.\n\nWe can also mention that the session subsystem should handle concurrency, expiration, etc.\n\nWe can also mention that the session store may be in-memory, database, Redis, etc.\n\nWe can also mention that the session subsystem may need to handle session regeneration.\n\nWe can", "L_val": 0.49345692816715, "quality_passed": false, "length_constraint_passed": false, "ast_equal": false, "similarity": 0.014942797104833061, "prompt_token_len": 72, "target_token_len": 412, "generated_token_len": 509, "latency_sec": 7.472166089341044, "backend": "vllm", "temperature": 0.0, "top_p": 1.0, "top_k": null, "seed": 0, "max_new_tokens": 512, "quality_threshold": 0.1, "length_factor": 0.15}
